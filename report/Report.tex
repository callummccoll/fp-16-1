% version 1

\documentclass[10point]{article}

% prelude

\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage[pdftex, backref, colorlinks, bookmarksnumbered=true]{hyperref}

\DefineVerbatimEnvironment{code}{Verbatim}{}

\newcommand{\highlight}[1]{\colorbox{yellow}{#1}}
\newcommand{\highlighttt}[1]{\highlight{{\tt#1}}}

\long\def\ignore#1{}

\begin{document}

\title{Visuals Report}
\author{Callum McColl\\
	    Andrew Paroz}
		
\maketitle

\begin{abstract}
We did stuff. And more stuff, then stuff happened.
\end{abstract}

\tableofcontents

\listoffigures

\section{Introduction}
The goal of this project was to create a program that could compile, execute and displayed a C program. It could then be used to go step-by-step through a C program in order to show how the memory and registers are effected by each line of C code. In order to learn functional programming and Mash as a template, this program was created using Haskell. The project could be divided into 5 separate sections, the C parser, the assembly parser, C to assembly code generation, the emulator and the GUI. These were then allocated to three groups, one group would create the C Parser, another the Assembly Parser and Symbol Table, and the last group the Emulator and GUI. The Code generation which converts a C Parse tree to an Assembly Parse tree was not assigned to any group. A diagram of this can be see in Figure \ref{fig:ProjectDiagram}.

\begin{figure}
\centering
\includegraphics[width=300px]{ProjectDiagram}
\caption{Project diagram showing all the main parts and group allocations.}
\label{fig:ProjectDiagram}
\end{figure}

The program that this project created is to be used as a learning tool to help teach C programming. C is a difficult language when starting as there are multiple ways to do the same thing in the language, but some ways are more 'right' than others. The compilers can also be very lenient and compile and run code that is not correct, leading to problems where code ends up running differently on different systems. By having a program that can go step-by-step through a C program, it will be much easier to show why errors are, and explain to students why a program is acting in that way.

Obviously the C language is very vast, so only a small subset was chosen to a implemented for this project. All variables are either an Int or a pointer, there are no structs and everything must be contained within a single file. This allowed the assembler and emulator to be much simpler and be possible to complete in the time we had.

Our group was the Visuals Group and was assigned to create the Emulator and GUI. Our project was significantly different from the other two groups which were creating parsers. In general, Callum was responsible for creating the GUI and Andrew created the Emulator and Environment. There was overlap between those sections when designing the programming interface for the emulator and environment, however most of the work was separate. Since the emulator uses an assembly parse tree, we also had to work with the group creating that in order to connect them together.

- ? More ? Maybe not. I dunno.

\section{Process and Design}
Describe process / design

\subsection{Process}
This project was approached using a prototyping methodology, where a design would be implemented, then assessed and modified or discarded. This approach was used as multiple different solutions were initially suggested for the implementation and each had to be tested and assessed. This method was also useful for filling in the blanks at the start of the project in regards to how it would work with the assembly parse tree, and how the GUI would interact with the emulator. This prototype method meant we could create a template for a part on how it may be designed, then easily update the program once that part was complete.

\subsection{Environment}
The creation of the Environment was an important early step as it defined the connection between the Emulator and the GUI. An Environment represent a single state of an emulated system, with memory, registers, inputs, outputs and the symbol table. The GUI can then use all the information in an Environment to display the state of a machine, while the Emulator can use that same information to emulate the machine running. Its data structures were mostly designed during an in-class meeting, then it was extended with many utility functions in order to increase its usefulness. 

Since the Environment was created at the start of the project, it was possible to generate a dummy environment with handwritten values in order to test the functionality of the Emulator and GUI. Once the assembly parse tree was completed however, this was replaced with a function that created an environment based on a parse tree and symbol table. This could be used to create the initial state of a system from an assembly file.

Before the parse tree was integrated, the assembly instructions were stored as plain strings, which made it easy to display in the GUI. However with the parse tree, the instructions were now data classes, so six utility functions were created that could give back an instruction as a string. This allowed the functions to be displayed in the way it was expected in the GUI and within error messages in the Emulator.

The last change to the Environment came at the end of the project when it was found we needed a flag to halt emulation and let the GUI know there were no more states. Originally the PC was used to figure out if the emulation was finished, if the PC did not change between two states, it must mean the program is finished. This was changed to a flag in the environment that was set to true when either the HALT command was run, or the program tried to read input and there was none.

\subsection{Emulator}
The emulator took a significant amount of time over the project and involved reading and executing assembly instructions to a virtual environment. Because this was a rather complex and large piece of code, it was broken in parts. First an instruction was read from memory based on the PC, the type of instruction was then used to call an associated function, for example, a MOVE instruction could call the actionMove function. Each function would then do what it needed to based on he parameters it was given. The largest part of the emulator was the destination and source functions, which needed to handle a wide range of different types of source and destination, each with their own special functions.

The first emulator was created without knowing what the assembly parse tree looked like, and was based off instructions given as strings. While this made the pattern matching for instructions easy, it lead to a huge list of permutations for both the source and destinations. Once the parse tree was available, all the strings were replaced with data types from the parse tree, which made calling the source and destination functions a little trickier, but improved their ability to be recursive with themselves.

Before the environment was designed, the emulator stored memory as just a list of strings. With the environment however, the memory became an IOArray, which made read and writing to it much easier and it was then possible to error check during emulation. If the program tried to read an instruction from a memory location where an Int or nothing was stored, a descriptive error could be printed. This was obviously very useful at the end of the project these error message became very important in testing to make sure the emulator was working correctly. The only bugs found when testing with the GUI revolved around simple logic mistakes with multiple levels of indirection. 

Upon review at the end of the project, many 'actions' within the emulator are repetitive, such as the maths operations and the decision functions. With a little work, these repetitive functions could be combined into a single one. This was a leftover from when string pattern matching was being used to read instructions and these functions were more different from each other.

\subsection{Graphical User Interface (GUI)}
\subsubsection{Cross-Platform GUI Solution}
The first task of our group was to determine how we would create a GUI using Haskell that could be completely cross-platform. Two methods were initially recommended, using Haskell to generate a HTML page that displayed everything, or using the GTK3 Hakell library to create an application window.

The first test was using a HTML page with a small amount of JavaScript to make it interactive. A screenshot of the example page can be seen in figure \ref{}. The idea was that once a program was compiled, it could generate this page with the all the program states loaded in as data. By using HTML, this file could then be opened on any system and the program could be looked at again without needing to be recompiled. However, it also had the huge drawback that the HTML page could not communicate with the emulator, which was too big a drawback for this project.

The next step was to test GTK3, and an example application was also made for it. This test program used Glade to structure the application window and GTK3 to draw it to the screen. A screenshot of the test program can be seen in figure \ref{fig:GTK3Test}. As a demo, it had very limited interactivity, allowing you to  step through a handwritten list of program states and nothing could be modified. It did demonstrate that GTK3 would indeed be suitable for the project, however the use of Glade to position elements on the window was not very useful as most of the windows ended up being built using code.

\begin{figure}
\centering
\includegraphics[width=300px]{GTK3TestScreenshot}
\caption{Screenshot of GTK3 test program.}
\label{fig:GTK3Test}
\end{figure}

\subsubsection{ ? }
- Write stuff here Callum.

\section{Design Details}
Details about the design.
present the grammars, etc - No grammers for our project.

- How to compile the project

\subsection{Compiling on Windows}
Although GTK3 is a cross platform library, getting everything installed on windows to compile it with Haskell is actually quite hard. This tutorial was written based off instructions from multiple websites that were all out of date. 
\linebreak \\
\textbf{Step 1}: Haskell on Windows
I used the Haskell Platform to install haskell on Windows. This provides haskell commands (ghc, cabal etc) through the windows command prompt. (\href{https://www.haskell.org/platform/}{https://www.haskell.org/platform/})

\noindent Though any Haskell installation for windows should work just fine for this.
\linebreak \\
\textbf{Step 2}: Get the GTK3 and Glade Binaries and dependencies
In order to get the up to date gtk3 binaries, and all the dependencies, we need to use msys. Download msys (\href{https://sourceforge.net/projects/msys2/}{https://sourceforge.net/projects/msys2/}) and install to a path without spaces. I installed to C:\\dev\\msys . You could do this without msys, but we need quite a few libraries, and they are not easy to find by themselves and it is not recommended to install them without msys.

Once installed, run msys and you'll get a console, this is what we get all the packages with. First we need to update msys. Type:
Run pacman -Syuu

Then quit the console and open it again.

Now we get the packages. Each package has a 32-bit and 64-bit version. Install the one suitable for you. I was on a 64-bit computer, so I used the 64-bit packages.

\noindent \textbf{pkg-config:}\\
pacman -S mingw-w64-i686-pkg-config    (32-bit)\\
pacman -S mingw-w64-x86\_64-pkg-config  (64-bit)\\

\noindent \textbf{cairo:}\\
pacman -S mingw-w64-i686-cairomm    (32-bit)\\
pacman -S mingw-w64-x86\_64-cairomm  (64-bit)\\

\noindent \textbf{glib:}\\
pacman -S mingw-w64-i686-glib2    (32-bit)\\
pacman -S mingw-w64-x86\_64-glib2  (64-bit)\\

\noindent \textbf{gtk2:}\\
pacman -S mingw-w64-i686-gtk2    (32-bit)\\
pacman -S mingw-w64-x86\_64-gtk2  (64-bit)\\

\noindent \textbf{gtk3:}\\
pacman -S mingw-w64-i686-gtk3    (32-bit)\\
pacman -S mingw-w64-x86\_64-gtk3  (64-bit)\\
\linebreak
\textbf{Step 3}: Haskell packages.
Now that we have all the c libraries, we can install the connected Haskell packages. First we need to link the c libraries so that Haskell can see them. To do this we need to edit a system environment variable.

Go to \verb"Computer -> System Properties ->" \\
\indent \verb"Advanced System Properties -> Environment Variables".

\noindent In the top box you'll see a variable called PATH, edit this. Values are separated by ; so add a ; to the end and then put the filepath to \verb"msys64\mingw64\bin". In my case this was \verb"C:\dev\msys64\mingw64\bin". Now open up a windows command prompt (with administer privileges).

\noindent Now for some Haskell libraries we need install. As always, use:\\
cabal update\\

\noindent Then:\\
cabal install alex\\
cabal install happy\\
cabal install gtk2hs-buildtools\\

\noindent Now it gets harder, there was/is a bug on Windows for a few of the Haskell library. glib, gio, pango and gtk3 all will fail to install directly with cabal. Try to install it first, but if you get an error about \verb"__debugbreak", then you'll have to do some editing.

Navigate to a location where we can unpack each package. I just used \verb"c:\dev\" where I installed msys and the Haskell platform, but the location doesn't matter. Then use cabal unpack to download and unpack the following packages.\\

\noindent cabal unpack glib\\
cabal unpack gio\\
cabal unpack pango\\
cabal unpack gtk\\
cabal unpack gtk3\\

\noindent Now go into each unpacked package and open the .cabal file, remove the \verb"-D__attribute__(A)=" attribute from the cpp-options.
\\ \linebreak

\noindent At the time of writing, there is a bug in gio that will cause this error: \\
\verb"System\GIO\File\IOError.chs:49:15: parse error on input '*'"
\linebreak

\noindent This bug has already been fixed in gtk2hs, but not in gio. You'll need to edit one of the source files. Find \verb"\gio-0.13.1.1\System\GIO\File\IOError.chs" and delete the \verb"{-# LANGUAGE CPP #-}" line. This file does not require cpp, and cpp ends up processing part of a comment, causing the error.
\\ \linebreak

\noindent Now manually install each of these pages, go into each unpacked package with the console and type: \\
cabal install \\
In the same order as when you unpacked them above.
\\ \linebreak

\noindent \textbf{Step 4}: Done \\
You're finally done and should be able to compile this project.

\section{Implementation}
\subsection{Environment}
\input{../Environment.lhs}

\subsection{Emulation}
\input{../Emulation.lhs}

\subsection{GUI}
- Callum fill this.

\section{Results, evidence of what works}
Screenshots of the GUI and output of printing an environment I guess.

\section{Conclusion}

\subsection{Callum McColl's Reflection}

\subsection{Andrew Paroz's Reflection}
On a whole I feel this project ran fairly well. I know out of everyone in the group I had the most free time since this was basically my only course, so I tried to jump in an do something wherever I could. Between Callum and myself things worked good and we were able to put our two parts together at the end fairly easily. We've worked together many times before so this was really nothing new to us. Using Slack to communicate between everyone seemed to be really useful and I found it a really good way to get in contact with other right away when I was having problems.

The use of 



\end{document}



